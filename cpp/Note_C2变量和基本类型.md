# 2.1 基本内置类型

### 2.1.1 算数类型

- 整型：字符、布尔
  - bool、char(8)、wchar_t(16)
  - char16_t（[Unicode字符](http://www.taodudu.cc/news/show-3089803.html?action=onClick)，16）
  - char32_t(32)
  - short(16)
  - int(16)
  - long(32)
  - long long(64)
- 浮点型
  - float(6位)
  - double(10位)
  - long double(10位)
- 其他整型：无符号类型和有符号类型
  - unsigned int -> unsigned
  - char 、unsigned char(0-255) 、signed char(-128-127)
  - 不为负下，优先使用无符号类型
  - int ：整型运算；算术表达式不用char\bool;执行浮点 运算用double

## 2.1.2 类型转换

表达式中**勿**混用无符号和有符号，同时存在时，有符号会自动转为无符号，负数时会出现异常结果

## 2.1.3 字面值常量

- 整型字面值（类型为可容纳下的最小尺寸：10-(int,long,longlong) 、8/16-(int,unsigned,long,unsigned long ,longlong ,unsigned long long)  short没有对应字面值）
- 浮点型字面值：带小数点，或用0e0,1e5,1e-6
- 字符和字符串（末尾’\0‘）字面值：太长可直接换行写
- 指定字面值类型：添加前缀或后缀
- 布尔：true,false
- 指针：nullptr

# 2.2 变量

基本类型 多个声明符  变量名;

## 2.2.1 初始化方法

- =0
- (0)
- {0}
- ={0}
- **使用{}初始化值存在丢信息（比如被截断）**，编译会报错
- 类内 类数据成员初始化时不可以用**（）**

默认初始化

- 函数外面的会被初始化为0

## 2.2.3 定义和声明的关系

定义后才能使用，声明可以在定义前面或者后面，但使用时必须在定义之后。当需要使用该定义的内容就需要声明。

- 声明规定变量的类型和名字，定义还申请内存空间
- 仅声明不定义，用extern并且不显示初始化；extern int i;
- 包含了显示初始化都是定义

- 声明的东西放在头文件，定义的东西放在源文件；类型的定义放在头文件
- 当需要使用其他源文件中的变量，就可以使用extern;

# 2.3 复合类型

引用：int &refval= ival，引用不是对象，只是变量的别名，**引用必须初始化，并且只能绑定在变量上（除非是常量引用）。**

即可以：const int &p=42, 不可以int &p=42;

指针：值的4种状态

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针（用nullptr），意味着没指向任何对象
- 无效指针，也就是上述情况之外的其他值
- \*void 指针，无法访问内存空间的对象，作用：拿他和其他指针比较、作为函数的输入输出，或者赋值给另外一个*void指针
- 变量的声明包括 基本数据类型和类型修饰符 ，一行可以声明多个变量

# 2.4 Const限定符

const常量特征仅在 改变常量时才发挥作用，const 对象**必须初始化！**

- const int i=getsize() ;运行时初始化
- const int i=42 ;编译时初始化

默认状态下，**const对象只在文件内有效，为了共享const变量，解决办法是对于const变量的声明和定义都添加extern；**

## 2.4.1 const的引用

对常量（字面值常量：整型、浮点型、字符、字符串、符号、序列，以及contst 修饰的）的引用不能修改所绑定的对象。

- 不能用一个非常量的引用去绑定一个常量对象
- 初始化常量引用时，引用类和所引用的对象类型要一致
- 或者初始化常量引用时 允许用任意表达式作为初始值，只要该表达式的结果能转换为引用的类型
- 常量引用绑定一个非常量时，不能通过常量引用改变引用的对象
- 但是此时改变绑定对象的值，引用也会变
- **当类型不一样时**，double dval=3.14;
  - const int temp=dval;
  - const int &ri = temp;
  - 此时改变dval值，ri的值不会变

## 2.4.2 指针和const

- 指向常量的指针，要存放常量对象的地址，只能使用指向常量的指针： const double pi=3.14 ;const double *cptr=&pi
- 指向常量的指针和常量引用一样，所指向的对象不一定是常量，只限制了不能通过这个指针或者这个引用去改变对象的值，但是有其他的方式可以改变对象的值。并且，**指向常量的指针值（地址）的可以改变**，直接更改指针的地址；因为对象不一定是常量，更改对象的值，指针指向对象的内容也会变。
- const 指针：允许把指针定义为常量，即地址指针中保存的地址不可以改变了，即初始化后不再可以更改指针的地址
- const double * const cptr= &pi, 说明cptr中的值不能再变了
- 常量指针可以指向非常量
- **常量指针**强调，该指针中的地址不可变
- **指向常量的指针**强调，不可以用该指针去改变所指对象
- **顶层const**: 指针本身是个常量，可以表示任意的对象是常量
- **底层const**,表示指针所指的对象是一个常量，与指针和引用的等复合类型的基本类型部分有关，指针类型既可以是顶层const，也可以是底层const，引用const都是底层const 
   - 对常量对象取地址是一种底层const
   - 当执行拷贝操作时，顶层const没关系
   - 拷入和拷出对象要具有相同的底层const资格，或者两个对象的数据类型能相互转换，非常量可以转常量。
   - 因为底层const表示的所指对象是一个常量，故拷贝时，只能是常量拷贝给常量，或是非常量拷贝给常量

### 2.4.4 constexpr 和常量表达式

常量表达式: 值不会改变，且在**编译过程中**就能得到计算结果的表达式。

- 字面值是常量表达式
- 用常量表达式初始化的const对象也是常量表达式
- 一个对象或表达式是否是常量表达式与它的数据类型和初始值共同决定：1、是const修饰，2、初始值也是在编译时就能得到

constexpr 变量：声明为constexpr的变量一定是一个常量，必须用常量表达式初始化。

可以constexpr定义一种简单的函数，在编译时就能获得值，可以用constexpr函数初始化constexpr变量；

当认定一个变量是一个常量表达式，就声明称constexpr类型

-  const定义了是一个常量，不可以改变，constexpr定义了一个常量表达式，不仅是一个常量，而且要求在编译时就确定值。
- ps: constexpr指针的初始值仅能是nullptr\0 ，或者存储于某个固定地址中的对象
- 定义于所有函数体外的对象其固定地址不变，能用来初始化constexpr指针。
- constexpr指针仅对指针有效，与所指对象无关
  - constexpr int *q=nullptr;  q是一个指向整数的常量指针，顶层const

## 2.5 处理类型

### 2.5.1 类型别名

typedef double wages;

 typedef wages base  ,*p;

 或 using wages = int ;

当别名用于复合类型或常量，可能会出现意想不到的结果：

typedef char *pstring ;//char *的别名 pstring

const  pstring cstr =0; //cstr是指向char 的常量指针，cstr不能变

即此时要将char *整体看，即pstring是基本数据类型，是一个指针，const pstring cstr是一个常量指针。

## 2.5.2 auto 类型说明符

让编译器通过初始值推断变量类型，**auto必须有初始值**

**auto 可以一条语句声明多个变量，但变量的初始基本数据类型得一样**

- 当引用作为auto的初始值时，会将引用的对象作为auto类型
- auto一般会忽略顶层const**（但当设置引用时，初始值中的顶层常量属性仍然保留）** ，保留底层const ：顶层cosnt, 修饰的是本身这个对象 ；底层const ,修饰的引用所绑定对象是const 
- 如果要推断出的类型是顶层const ,需要明确指出

## 2.5.3 decltype 类型指示符

分析表达式，不计算得推断出类型，使用：decltype( f() ) sum =x;

- 与auto的区别：处理顶层const和引用时，若decltype使用表达式是一个变量，则返回的是该变量的类型
  - const int ci =0, &cj =ci;
  - decltype( ci ) x = 0;  //x 的类型是 ci，是const int
  - decltype(cj) y=x;  // y 的类型是 cj的类型，是const int &
  - 引用在其他地方都当作所绑定对象的同义词，除了在decltype处
  - 当使用的表达式不是一个变量时，返回表达式结果对应的类型，
    - int i=42 ,&r=i;
    - decltype ( r + 0 ) b ;// r+0 结果是int 类型，返回int ; 如果仅decltype ( r ), 则返回引用类型
  - **表达式内容是解引用时** *p , 返回引用类型
  - 更重要的是：decltype的结果类型与表达式密切相关，加括号和不加括号不一样，变量加上一层括号，则编译器会当做表达式
    - eg : 给变量加上一层括号，变量作为一种可以赋左值的特殊表达式，这样decltype得到的是引用类型
- decltype( (var) ) ,永远是引用，decltype( var )只有var 是引用类型时才是 引用

## 2.6自定义数据结构

- Struct 类名 { 类体 }  ；

- 类数据成员可以提供一个类内初始值，创建对象时用于初始化数据成员，没有初始值的成员将被默认初始化；

- **初始化方法：{} 或= var  , 不能用（），避免变成函数声明**

- Class 也可以定义类

- 预处理器

  - 在编译器之前执行的一段程序

  - 头文件编写，为了避免重复定义，需加入以下代码

    - 头文件保护符依赖于预处理变量（定义\未定义）

    ```
    #ifndef _HEADERNAME_H_
    #define _HEADERNAME_H_
     ....自定义头文件
    #endif
    ```

  - 