// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serialization/src/BPlusTree.proto

#ifndef PROTOBUF_INCLUDED_serialization_2fsrc_2fBPlusTree_2eproto
#define PROTOBUF_INCLUDED_serialization_2fsrc_2fBPlusTree_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_serialization_2fsrc_2fBPlusTree_2eproto 

namespace protobuf_serialization_2fsrc_2fBPlusTree_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_serialization_2fsrc_2fBPlusTree_2eproto
class BPlusTreeNodeS;
class BPlusTreeNodeSDefaultTypeInternal;
extern BPlusTreeNodeSDefaultTypeInternal _BPlusTreeNodeS_default_instance_;
class BPlusTreeS;
class BPlusTreeSDefaultTypeInternal;
extern BPlusTreeSDefaultTypeInternal _BPlusTreeS_default_instance_;
class InternalNodeS;
class InternalNodeSDefaultTypeInternal;
extern InternalNodeSDefaultTypeInternal _InternalNodeS_default_instance_;
class LeafNodeS;
class LeafNodeSDefaultTypeInternal;
extern LeafNodeSDefaultTypeInternal _LeafNodeS_default_instance_;
namespace google {
namespace protobuf {
template<> ::BPlusTreeNodeS* Arena::CreateMaybeMessage<::BPlusTreeNodeS>(Arena*);
template<> ::BPlusTreeS* Arena::CreateMaybeMessage<::BPlusTreeS>(Arena*);
template<> ::InternalNodeS* Arena::CreateMaybeMessage<::InternalNodeS>(Arena*);
template<> ::LeafNodeS* Arena::CreateMaybeMessage<::LeafNodeS>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class BPlusTreeS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BPlusTreeS) */ {
 public:
  BPlusTreeS();
  virtual ~BPlusTreeS();

  BPlusTreeS(const BPlusTreeS& from);

  inline BPlusTreeS& operator=(const BPlusTreeS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BPlusTreeS(BPlusTreeS&& from) noexcept
    : BPlusTreeS() {
    *this = ::std::move(from);
  }

  inline BPlusTreeS& operator=(BPlusTreeS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BPlusTreeS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BPlusTreeS* internal_default_instance() {
    return reinterpret_cast<const BPlusTreeS*>(
               &_BPlusTreeS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BPlusTreeS* other);
  friend void swap(BPlusTreeS& a, BPlusTreeS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BPlusTreeS* New() const final {
    return CreateMaybeMessage<BPlusTreeS>(NULL);
  }

  BPlusTreeS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BPlusTreeS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BPlusTreeS& from);
  void MergeFrom(const BPlusTreeS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BPlusTreeS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .BPlusTreeNodeS root = 1;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 1;
  private:
  const ::BPlusTreeNodeS& _internal_root() const;
  public:
  const ::BPlusTreeNodeS& root() const;
  ::BPlusTreeNodeS* release_root();
  ::BPlusTreeNodeS* mutable_root();
  void set_allocated_root(::BPlusTreeNodeS* root);

  // .LeafNodeS start = 4;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 4;
  private:
  const ::LeafNodeS& _internal_start() const;
  public:
  const ::LeafNodeS& start() const;
  ::LeafNodeS* release_start();
  ::LeafNodeS* mutable_start();
  void set_allocated_start(::LeafNodeS* start);

  // int32 MAX_KEYS = 2;
  void clear_max_keys();
  static const int kMAXKEYSFieldNumber = 2;
  ::google::protobuf::int32 max_keys() const;
  void set_max_keys(::google::protobuf::int32 value);

  // int32 MIN_KEYS = 3;
  void clear_min_keys();
  static const int kMINKEYSFieldNumber = 3;
  ::google::protobuf::int32 min_keys() const;
  void set_min_keys(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BPlusTreeS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::BPlusTreeNodeS* root_;
  ::LeafNodeS* start_;
  ::google::protobuf::int32 max_keys_;
  ::google::protobuf::int32 min_keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serialization_2fsrc_2fBPlusTree_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BPlusTreeNodeS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BPlusTreeNodeS) */ {
 public:
  BPlusTreeNodeS();
  virtual ~BPlusTreeNodeS();

  BPlusTreeNodeS(const BPlusTreeNodeS& from);

  inline BPlusTreeNodeS& operator=(const BPlusTreeNodeS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BPlusTreeNodeS(BPlusTreeNodeS&& from) noexcept
    : BPlusTreeNodeS() {
    *this = ::std::move(from);
  }

  inline BPlusTreeNodeS& operator=(BPlusTreeNodeS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BPlusTreeNodeS& default_instance();

  enum NodeTypeCase {
    kLeafNode = 1,
    kInternalNode = 2,
    NODE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BPlusTreeNodeS* internal_default_instance() {
    return reinterpret_cast<const BPlusTreeNodeS*>(
               &_BPlusTreeNodeS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BPlusTreeNodeS* other);
  friend void swap(BPlusTreeNodeS& a, BPlusTreeNodeS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BPlusTreeNodeS* New() const final {
    return CreateMaybeMessage<BPlusTreeNodeS>(NULL);
  }

  BPlusTreeNodeS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BPlusTreeNodeS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BPlusTreeNodeS& from);
  void MergeFrom(const BPlusTreeNodeS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BPlusTreeNodeS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .LeafNodeS leaf_node = 1;
  bool has_leaf_node() const;
  void clear_leaf_node();
  static const int kLeafNodeFieldNumber = 1;
  private:
  const ::LeafNodeS& _internal_leaf_node() const;
  public:
  const ::LeafNodeS& leaf_node() const;
  ::LeafNodeS* release_leaf_node();
  ::LeafNodeS* mutable_leaf_node();
  void set_allocated_leaf_node(::LeafNodeS* leaf_node);

  // .InternalNodeS internal_node = 2;
  bool has_internal_node() const;
  void clear_internal_node();
  static const int kInternalNodeFieldNumber = 2;
  private:
  const ::InternalNodeS& _internal_internal_node() const;
  public:
  const ::InternalNodeS& internal_node() const;
  ::InternalNodeS* release_internal_node();
  ::InternalNodeS* mutable_internal_node();
  void set_allocated_internal_node(::InternalNodeS* internal_node);

  void clear_node_type();
  NodeTypeCase node_type_case() const;
  // @@protoc_insertion_point(class_scope:BPlusTreeNodeS)
 private:
  void set_has_leaf_node();
  void set_has_internal_node();

  inline bool has_node_type() const;
  inline void clear_has_node_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union NodeTypeUnion {
    NodeTypeUnion() {}
    ::LeafNodeS* leaf_node_;
    ::InternalNodeS* internal_node_;
  } node_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_serialization_2fsrc_2fBPlusTree_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InternalNodeS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InternalNodeS) */ {
 public:
  InternalNodeS();
  virtual ~InternalNodeS();

  InternalNodeS(const InternalNodeS& from);

  inline InternalNodeS& operator=(const InternalNodeS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InternalNodeS(InternalNodeS&& from) noexcept
    : InternalNodeS() {
    *this = ::std::move(from);
  }

  inline InternalNodeS& operator=(InternalNodeS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalNodeS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InternalNodeS* internal_default_instance() {
    return reinterpret_cast<const InternalNodeS*>(
               &_InternalNodeS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(InternalNodeS* other);
  friend void swap(InternalNodeS& a, InternalNodeS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InternalNodeS* New() const final {
    return CreateMaybeMessage<InternalNodeS>(NULL);
  }

  InternalNodeS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InternalNodeS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InternalNodeS& from);
  void MergeFrom(const InternalNodeS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalNodeS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  ::google::protobuf::int32 keys(int index) const;
  void set_keys(int index, ::google::protobuf::int32 value);
  void add_keys(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      keys() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_keys();

  // repeated .BPlusTreeNodeS children = 2;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 2;
  ::BPlusTreeNodeS* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::BPlusTreeNodeS >*
      mutable_children();
  const ::BPlusTreeNodeS& children(int index) const;
  ::BPlusTreeNodeS* add_children();
  const ::google::protobuf::RepeatedPtrField< ::BPlusTreeNodeS >&
      children() const;

  // @@protoc_insertion_point(class_scope:InternalNodeS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > keys_;
  mutable int _keys_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::BPlusTreeNodeS > children_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serialization_2fsrc_2fBPlusTree_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeafNodeS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LeafNodeS) */ {
 public:
  LeafNodeS();
  virtual ~LeafNodeS();

  LeafNodeS(const LeafNodeS& from);

  inline LeafNodeS& operator=(const LeafNodeS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeafNodeS(LeafNodeS&& from) noexcept
    : LeafNodeS() {
    *this = ::std::move(from);
  }

  inline LeafNodeS& operator=(LeafNodeS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeafNodeS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeafNodeS* internal_default_instance() {
    return reinterpret_cast<const LeafNodeS*>(
               &_LeafNodeS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LeafNodeS* other);
  friend void swap(LeafNodeS& a, LeafNodeS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeafNodeS* New() const final {
    return CreateMaybeMessage<LeafNodeS>(NULL);
  }

  LeafNodeS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeafNodeS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LeafNodeS& from);
  void MergeFrom(const LeafNodeS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafNodeS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  ::google::protobuf::int32 keys(int index) const;
  void set_keys(int index, ::google::protobuf::int32 value);
  void add_keys(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      keys() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_keys();

  // repeated uint64 values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  ::google::protobuf::uint64 values(int index) const;
  void set_values(int index, ::google::protobuf::uint64 value);
  void add_values(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_values();

  // .LeafNodeS next = 3;
  bool has_next() const;
  void clear_next();
  static const int kNextFieldNumber = 3;
  private:
  const ::LeafNodeS& _internal_next() const;
  public:
  const ::LeafNodeS& next() const;
  ::LeafNodeS* release_next();
  ::LeafNodeS* mutable_next();
  void set_allocated_next(::LeafNodeS* next);

  // @@protoc_insertion_point(class_scope:LeafNodeS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > keys_;
  mutable int _keys_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > values_;
  mutable int _values_cached_byte_size_;
  ::LeafNodeS* next_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serialization_2fsrc_2fBPlusTree_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BPlusTreeS

// .BPlusTreeNodeS root = 1;
inline bool BPlusTreeS::has_root() const {
  return this != internal_default_instance() && root_ != NULL;
}
inline void BPlusTreeS::clear_root() {
  if (GetArenaNoVirtual() == NULL && root_ != NULL) {
    delete root_;
  }
  root_ = NULL;
}
inline const ::BPlusTreeNodeS& BPlusTreeS::_internal_root() const {
  return *root_;
}
inline const ::BPlusTreeNodeS& BPlusTreeS::root() const {
  const ::BPlusTreeNodeS* p = root_;
  // @@protoc_insertion_point(field_get:BPlusTreeS.root)
  return p != NULL ? *p : *reinterpret_cast<const ::BPlusTreeNodeS*>(
      &::_BPlusTreeNodeS_default_instance_);
}
inline ::BPlusTreeNodeS* BPlusTreeS::release_root() {
  // @@protoc_insertion_point(field_release:BPlusTreeS.root)
  
  ::BPlusTreeNodeS* temp = root_;
  root_ = NULL;
  return temp;
}
inline ::BPlusTreeNodeS* BPlusTreeS::mutable_root() {
  
  if (root_ == NULL) {
    auto* p = CreateMaybeMessage<::BPlusTreeNodeS>(GetArenaNoVirtual());
    root_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BPlusTreeS.root)
  return root_;
}
inline void BPlusTreeS::set_allocated_root(::BPlusTreeNodeS* root) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete root_;
  }
  if (root) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      root = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:BPlusTreeS.root)
}

// int32 MAX_KEYS = 2;
inline void BPlusTreeS::clear_max_keys() {
  max_keys_ = 0;
}
inline ::google::protobuf::int32 BPlusTreeS::max_keys() const {
  // @@protoc_insertion_point(field_get:BPlusTreeS.MAX_KEYS)
  return max_keys_;
}
inline void BPlusTreeS::set_max_keys(::google::protobuf::int32 value) {
  
  max_keys_ = value;
  // @@protoc_insertion_point(field_set:BPlusTreeS.MAX_KEYS)
}

// int32 MIN_KEYS = 3;
inline void BPlusTreeS::clear_min_keys() {
  min_keys_ = 0;
}
inline ::google::protobuf::int32 BPlusTreeS::min_keys() const {
  // @@protoc_insertion_point(field_get:BPlusTreeS.MIN_KEYS)
  return min_keys_;
}
inline void BPlusTreeS::set_min_keys(::google::protobuf::int32 value) {
  
  min_keys_ = value;
  // @@protoc_insertion_point(field_set:BPlusTreeS.MIN_KEYS)
}

// .LeafNodeS start = 4;
inline bool BPlusTreeS::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void BPlusTreeS::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::LeafNodeS& BPlusTreeS::_internal_start() const {
  return *start_;
}
inline const ::LeafNodeS& BPlusTreeS::start() const {
  const ::LeafNodeS* p = start_;
  // @@protoc_insertion_point(field_get:BPlusTreeS.start)
  return p != NULL ? *p : *reinterpret_cast<const ::LeafNodeS*>(
      &::_LeafNodeS_default_instance_);
}
inline ::LeafNodeS* BPlusTreeS::release_start() {
  // @@protoc_insertion_point(field_release:BPlusTreeS.start)
  
  ::LeafNodeS* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::LeafNodeS* BPlusTreeS::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::LeafNodeS>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BPlusTreeS.start)
  return start_;
}
inline void BPlusTreeS::set_allocated_start(::LeafNodeS* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:BPlusTreeS.start)
}

// -------------------------------------------------------------------

// BPlusTreeNodeS

// .LeafNodeS leaf_node = 1;
inline bool BPlusTreeNodeS::has_leaf_node() const {
  return node_type_case() == kLeafNode;
}
inline void BPlusTreeNodeS::set_has_leaf_node() {
  _oneof_case_[0] = kLeafNode;
}
inline void BPlusTreeNodeS::clear_leaf_node() {
  if (has_leaf_node()) {
    delete node_type_.leaf_node_;
    clear_has_node_type();
  }
}
inline const ::LeafNodeS& BPlusTreeNodeS::_internal_leaf_node() const {
  return *node_type_.leaf_node_;
}
inline ::LeafNodeS* BPlusTreeNodeS::release_leaf_node() {
  // @@protoc_insertion_point(field_release:BPlusTreeNodeS.leaf_node)
  if (has_leaf_node()) {
    clear_has_node_type();
      ::LeafNodeS* temp = node_type_.leaf_node_;
    node_type_.leaf_node_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LeafNodeS& BPlusTreeNodeS::leaf_node() const {
  // @@protoc_insertion_point(field_get:BPlusTreeNodeS.leaf_node)
  return has_leaf_node()
      ? *node_type_.leaf_node_
      : *reinterpret_cast< ::LeafNodeS*>(&::_LeafNodeS_default_instance_);
}
inline ::LeafNodeS* BPlusTreeNodeS::mutable_leaf_node() {
  if (!has_leaf_node()) {
    clear_node_type();
    set_has_leaf_node();
    node_type_.leaf_node_ = CreateMaybeMessage< ::LeafNodeS >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:BPlusTreeNodeS.leaf_node)
  return node_type_.leaf_node_;
}

// .InternalNodeS internal_node = 2;
inline bool BPlusTreeNodeS::has_internal_node() const {
  return node_type_case() == kInternalNode;
}
inline void BPlusTreeNodeS::set_has_internal_node() {
  _oneof_case_[0] = kInternalNode;
}
inline void BPlusTreeNodeS::clear_internal_node() {
  if (has_internal_node()) {
    delete node_type_.internal_node_;
    clear_has_node_type();
  }
}
inline const ::InternalNodeS& BPlusTreeNodeS::_internal_internal_node() const {
  return *node_type_.internal_node_;
}
inline ::InternalNodeS* BPlusTreeNodeS::release_internal_node() {
  // @@protoc_insertion_point(field_release:BPlusTreeNodeS.internal_node)
  if (has_internal_node()) {
    clear_has_node_type();
      ::InternalNodeS* temp = node_type_.internal_node_;
    node_type_.internal_node_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::InternalNodeS& BPlusTreeNodeS::internal_node() const {
  // @@protoc_insertion_point(field_get:BPlusTreeNodeS.internal_node)
  return has_internal_node()
      ? *node_type_.internal_node_
      : *reinterpret_cast< ::InternalNodeS*>(&::_InternalNodeS_default_instance_);
}
inline ::InternalNodeS* BPlusTreeNodeS::mutable_internal_node() {
  if (!has_internal_node()) {
    clear_node_type();
    set_has_internal_node();
    node_type_.internal_node_ = CreateMaybeMessage< ::InternalNodeS >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:BPlusTreeNodeS.internal_node)
  return node_type_.internal_node_;
}

inline bool BPlusTreeNodeS::has_node_type() const {
  return node_type_case() != NODE_TYPE_NOT_SET;
}
inline void BPlusTreeNodeS::clear_has_node_type() {
  _oneof_case_[0] = NODE_TYPE_NOT_SET;
}
inline BPlusTreeNodeS::NodeTypeCase BPlusTreeNodeS::node_type_case() const {
  return BPlusTreeNodeS::NodeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalNodeS

// repeated int32 keys = 1;
inline int InternalNodeS::keys_size() const {
  return keys_.size();
}
inline void InternalNodeS::clear_keys() {
  keys_.Clear();
}
inline ::google::protobuf::int32 InternalNodeS::keys(int index) const {
  // @@protoc_insertion_point(field_get:InternalNodeS.keys)
  return keys_.Get(index);
}
inline void InternalNodeS::set_keys(int index, ::google::protobuf::int32 value) {
  keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:InternalNodeS.keys)
}
inline void InternalNodeS::add_keys(::google::protobuf::int32 value) {
  keys_.Add(value);
  // @@protoc_insertion_point(field_add:InternalNodeS.keys)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InternalNodeS::keys() const {
  // @@protoc_insertion_point(field_list:InternalNodeS.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InternalNodeS::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:InternalNodeS.keys)
  return &keys_;
}

// repeated .BPlusTreeNodeS children = 2;
inline int InternalNodeS::children_size() const {
  return children_.size();
}
inline void InternalNodeS::clear_children() {
  children_.Clear();
}
inline ::BPlusTreeNodeS* InternalNodeS::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:InternalNodeS.children)
  return children_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::BPlusTreeNodeS >*
InternalNodeS::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:InternalNodeS.children)
  return &children_;
}
inline const ::BPlusTreeNodeS& InternalNodeS::children(int index) const {
  // @@protoc_insertion_point(field_get:InternalNodeS.children)
  return children_.Get(index);
}
inline ::BPlusTreeNodeS* InternalNodeS::add_children() {
  // @@protoc_insertion_point(field_add:InternalNodeS.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BPlusTreeNodeS >&
InternalNodeS::children() const {
  // @@protoc_insertion_point(field_list:InternalNodeS.children)
  return children_;
}

// -------------------------------------------------------------------

// LeafNodeS

// repeated int32 keys = 1;
inline int LeafNodeS::keys_size() const {
  return keys_.size();
}
inline void LeafNodeS::clear_keys() {
  keys_.Clear();
}
inline ::google::protobuf::int32 LeafNodeS::keys(int index) const {
  // @@protoc_insertion_point(field_get:LeafNodeS.keys)
  return keys_.Get(index);
}
inline void LeafNodeS::set_keys(int index, ::google::protobuf::int32 value) {
  keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:LeafNodeS.keys)
}
inline void LeafNodeS::add_keys(::google::protobuf::int32 value) {
  keys_.Add(value);
  // @@protoc_insertion_point(field_add:LeafNodeS.keys)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LeafNodeS::keys() const {
  // @@protoc_insertion_point(field_list:LeafNodeS.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LeafNodeS::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:LeafNodeS.keys)
  return &keys_;
}

// repeated uint64 values = 2;
inline int LeafNodeS::values_size() const {
  return values_.size();
}
inline void LeafNodeS::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint64 LeafNodeS::values(int index) const {
  // @@protoc_insertion_point(field_get:LeafNodeS.values)
  return values_.Get(index);
}
inline void LeafNodeS::set_values(int index, ::google::protobuf::uint64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:LeafNodeS.values)
}
inline void LeafNodeS::add_values(::google::protobuf::uint64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:LeafNodeS.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
LeafNodeS::values() const {
  // @@protoc_insertion_point(field_list:LeafNodeS.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
LeafNodeS::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:LeafNodeS.values)
  return &values_;
}

// .LeafNodeS next = 3;
inline bool LeafNodeS::has_next() const {
  return this != internal_default_instance() && next_ != NULL;
}
inline void LeafNodeS::clear_next() {
  if (GetArenaNoVirtual() == NULL && next_ != NULL) {
    delete next_;
  }
  next_ = NULL;
}
inline const ::LeafNodeS& LeafNodeS::_internal_next() const {
  return *next_;
}
inline const ::LeafNodeS& LeafNodeS::next() const {
  const ::LeafNodeS* p = next_;
  // @@protoc_insertion_point(field_get:LeafNodeS.next)
  return p != NULL ? *p : *reinterpret_cast<const ::LeafNodeS*>(
      &::_LeafNodeS_default_instance_);
}
inline ::LeafNodeS* LeafNodeS::release_next() {
  // @@protoc_insertion_point(field_release:LeafNodeS.next)
  
  ::LeafNodeS* temp = next_;
  next_ = NULL;
  return temp;
}
inline ::LeafNodeS* LeafNodeS::mutable_next() {
  
  if (next_ == NULL) {
    auto* p = CreateMaybeMessage<::LeafNodeS>(GetArenaNoVirtual());
    next_ = p;
  }
  // @@protoc_insertion_point(field_mutable:LeafNodeS.next)
  return next_;
}
inline void LeafNodeS::set_allocated_next(::LeafNodeS* next) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete next_;
  }
  if (next) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      next = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, next, submessage_arena);
    }
    
  } else {
    
  }
  next_ = next;
  // @@protoc_insertion_point(field_set_allocated:LeafNodeS.next)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_serialization_2fsrc_2fBPlusTree_2eproto
